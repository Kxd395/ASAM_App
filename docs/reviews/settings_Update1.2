Absolutely—this is fixable, and you can make it smooth:

## What’s happening

* The sheet resizes and “jumps” when the keyboard appears and when the *Action Taken* picker expands/collapses, so focus moves and the sheet tries to re-layout.
* You’re not explicitly focusing the Notes field, so the system decides where to keep focus and sometimes scrolls the content out of view.

## Goals

1. Auto-focus the **Notes** `TextEditor` the moment an Action is picked (it’s required).
2. Keep the sheet stable when the keyboard shows (no “shooting off”).
3. Let the user pull the sheet larger/smaller.

---

## Drop-in SwiftUI patch (pure SwiftUI)

```swift
// SafetyReviewSheet.swift

import SwiftUI

struct SafetyReviewSheet: View {
    enum Field { case notes }

    @State private var actionTaken: ActionChoice?   // your enum/binding
    @State private var notes: String = ""
    @State private var acknowledged = false

    @FocusState private var focusedField: Field?
    @Environment(\.dynamicTypeSize) private var dts

    var body: some View {
        ScrollViewReader { proxy in
            ScrollView {
                VStack(spacing: 16) {
                    // … your header + escalation criteria …

                    // REQUIRED ACTION
                    Section {
                        // Your Action picker here…
                        ActionPicker(selection: $actionTaken)

                        // NOTES (required)
                        TextEditor(text: $notes)
                            .focused($focusedField, equals: .notes)
                            .id("notes")
                            .frame(minHeight: 120)
                            .overlay(
                                RoundedRectangle(cornerRadius: 12)
                                    .stroke(.quaternary)
                            )
                            .textInputAutocapitalization(.sentences)
                            .submitLabel(.done)
                    } header: {
                        Text("REQUIRED ACTION")
                            .font(.headline)
                    }

                    Toggle("I have reviewed safety criteria and documented appropriate action",
                           isOn: $acknowledged)
                        .toggleStyle(.switch)
                }
                .padding(20)
            }
            // ---- Keyboard & layout behavior
            .scrollDismissesKeyboard(.interactively)
            .ignoresSafeArea(.keyboard, edges: .bottom)   // prevents sheet from “jumping”
            .onChange(of: actionTaken) { _, newValue in
                guard newValue != nil else { return }
                // Let the picker close/layout, then focus + scroll to notes
                DispatchQueue.main.asyncAfter(deadline: .now() + 0.15) {
                    focusedField = .notes
                    withAnimation(.easeInOut) {
                        proxy.scrollTo("notes", anchor: .bottom)
                    }
                }
            }
            .onAppear {
                // If action already chosen, put user straight into notes
                if actionTaken != nil && notes.isEmpty {
                    DispatchQueue.main.async {
                        focusedField = .notes
                    }
                }
            }
        }
        // ---- Make it pullable/resizable & stable
        .presentationDetents(preferredDetents)
        .presentationDragIndicator(.visible)
        .interactiveDismissDisabled(true) // it’s required—user must complete
        .toolbar {
            ToolbarItem(placement: .topBarLeading) {
                Button("Cancel") { /* dismiss */ }
            }
            ToolbarItem(placement: .topBarTrailing) {
                Button("Continue") { /* validate + proceed */ }
                    .disabled(!canContinue)
            }
        }
    }

    private var canContinue: Bool {
        (actionTaken != nil) && !notes.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty && acknowledged
    }

    // Prefer a larger default for iPad/large text, medium for normal
    private var preferredDetents: Set<PresentationDetent> {
        if dts >= .accessibility2 {
            return [.fraction(0.6), .large]
        } else {
            return [.medium, .large]
        }
    }
}
```

### Why these bits matter

* **`.focused($focusedField, equals: .notes)`** + **`.onChange(of: actionTaken)`**: forces the cursor into Notes the moment an action is picked.
* **`DispatchQueue.main.asyncAfter(0.15)`**: tiny defer lets the picker collapse and the layout settle before focusing/scrolling—removes the “shoot off” jump.
* **`ScrollViewReader + proxy.scrollTo("notes")`**: guarantees Notes is visible above the keyboard.
* **`ignoresSafeArea(.keyboard, edges: .bottom)`**: keeps the sheet height consistent as the keyboard animates.
* **`.presentationDetents([.medium, .large])`**: makes the sheet pullable; you can add `.fraction(0.45)` if you want an extra compact state.
* **`.interactiveDismissDisabled(true)`**: prevents accidental dismissal while the required Notes are empty.

---

## If you want bullet-proof focusing (UIKit bridge)

Sometimes SwiftUI focus can still be flaky on iPad sheets. This tiny wrapper gives you a reliable “becomeFirstResponder”:

```swift
struct AutofocusTextView: UIViewRepresentable {
    @Binding var text: String
    var shouldFocus: Bool

    func makeUIView(context: Context) -> UITextView {
        let tv = UITextView()
        tv.font = .preferredFont(forTextStyle: .body)
        tv.isScrollEnabled = true
        tv.delegate = context.coordinator
        return tv
    }

    func updateUIView(_ uiView: UITextView, context: Context) {
        if uiView.text != text { uiView.text = text }
        if shouldFocus, uiView.window != nil, !uiView.isFirstResponder {
            uiView.becomeFirstResponder()
        }
    }

    func makeCoordinator() -> Coordinator { Coordinator(self) }
    final class Coordinator: NSObject, UITextViewDelegate {
        var parent: AutofocusTextView
        init(_ parent: AutofocusTextView) { self.parent = parent }
        func textViewDidChange(_ textView: UITextView) {
            parent.text = textView.text
        }
    }
}
```

Use it in place of `TextEditor`:

```swift
AutofocusTextView(text: $notes, shouldFocus: actionTaken != nil && notes.isEmpty)
    .frame(minHeight: 120)
    .id("notes")
```

---

## Nice-to-haves (quick wins)

* **Disable Continue until valid** (included in `canContinue`).
* **Auto-insert a stub** when action is “No immediate risk identified”, e.g. `notes = "No immediate risk identified."` then focus at end (`TextSelection` if you have iOS 17 APIs).
* **Haptics** when the field becomes required but empty:

  ```swift
  if !canContinue { UINotificationFeedbackGenerator().notificationOccurred(.warning) }
  ```
* **Settings tie-in**: default sheet detent and text size already exist in your Settings model—use them to choose detents or scale fonts.

---

## Common pitfalls (avoid the jump)

* Putting the picker and the notes field in different conditional branches of the view hierarchy causes re-mounting; keep them in place and toggle visibility to avoid layout thrash.
* Animations during focus change can make the jump worse; use a simple `.easeInOut` only for the `scrollTo`, not for inserting/removing large sections.
* Don’t wrap the whole sheet in `GeometryReader` just to “watch” keyboard height—`ignoresSafeArea(.keyboard)` is simpler and more reliable.

---

If you want, I can also give you a tiny validator that **automatically focuses Notes** when the user taps **Continue** with notes empty (and shows a one-line inline error) — just say the word.
>>>>>


Got you. Here’s a complete, drop-in package to make **Action Taken → Notes** buttery-smooth: auto-focus, no jumping, pullable sheet, validation, haptics, IDs for UI tests, and Settings tie-in.

---

# 1) Drop-in sheet (SwiftUI only)

`SafetyReviewSheet.swift` — paste as a new file and swap your existing sheet with this one.

```swift
import SwiftUI
import Combine

// MARK: - Types you likely already have
public enum ActionChoice: String, CaseIterable, Identifiable {
    case noImmediateRisk = "No immediate risk identified"
    case escalatedToED   = "Escalated to emergency services"
    case notifiedMD      = "Notified on-call clinician"
    case other           = "Other"
    public var id: String { rawValue }
}

// Optional Settings object; wire yours if you already have it.
final class AppSettings: ObservableObject {
    @AppStorage("ui.defaultSheetDetentIndex") var defaultSheetDetentIndex: Int = 1 // 0=medium 1=large
    @AppStorage("ui.textSizeIndex") var textSizeIndex: Int = 3
    @AppStorage("ui.reduceMotion") var reduceMotion: Bool = false
}

struct SafetyReviewResult {
    let action: ActionChoice
    let notes: String
    let acknowledged: Bool
}

// MARK: - Sheet

struct SafetyReviewSheet: View {
    enum Field { case notes }

    // In/out bindings
    @Binding var isPresented: Bool
    let onContinue: (SafetyReviewResult) -> Void

    // State
    @State private var actionTaken: ActionChoice? = nil
    @State private var notes: String = ""
    @State private var acknowledged = false
    @State private var showInlineError = false

    // Focus + env
    @FocusState private var focusedField: Field?
    @Environment(\.dynamicTypeSize) private var dts
    @EnvironmentObject private var settings: AppSettings

    var body: some View {
        ScrollViewReader { proxy in
            ScrollView {
                VStack(spacing: 16) {

                    // --- Header / Alert
                    headerCard

                    // --- Criteria list (your existing content)
                    escalationCriteriaCard

                    // --- Required Action
                    Section {
                        actionPicker

                        notesEditor
                            .id("notes")
                            .focused($focusedField, equals: .notes)

                        if showInlineError && notes.trimmed.isEmpty {
                            Text("Notes are required.")
                                .foregroundStyle(.red)
                                .font(.footnote)
                                .frame(maxWidth: .infinity, alignment: .leading)
                                .accessibilityIdentifier("notesError")
                        }
                    } header: {
                        Text("REQUIRED ACTION").font(.headline)
                    }

                    // --- Acknowledgement
                    Toggle("I have reviewed safety criteria and documented appropriate action",
                           isOn: $acknowledged)
                        .toggleStyle(.switch)
                        .accessibilityIdentifier("ackToggle")
                }
                .padding(20)
            }
            .scrollDismissesKeyboard(.interactively)
            .ignoresSafeArea(.keyboard, edges: .bottom)     // prevents sheet “jump”
            .onChange(of: actionTaken) { _, newValue in
                guard newValue != nil else { return }
                // Allow picker to collapse before focusing.
                DispatchQueue.main.asyncAfter(deadline: .now() + 0.15) {
                    // Optional: auto-stub notes for the common case
                    if notes.isEmpty, newValue == .noImmediateRisk {
                        notes = "No immediate risk identified."
                    }
                    focusedField = .notes
                    withAppropriateAnimation {
                        proxy.scrollTo("notes", anchor: .bottom)
                    }
                }
            }
        }
        .presentationDetents(preferredDetents)
        .presentationDragIndicator(.visible)
        .interactiveDismissDisabled(true) // must complete
        .toolbar {
            ToolbarItem(placement: .topBarLeading) {
                Button("Cancel") { isPresented = false }
                    .accessibilityIdentifier("cancelButton")
            }
            ToolbarItem(placement: .topBarTrailing) {
                Button("Continue") { validateAndContinue() }
                    .disabled(!canContinue)
                    .accessibilityIdentifier("continueButton")
            }
        }
        .accessibilityIdentifier("safetyReviewSheet")
        .onAppear {
            // If the action is preselected upstream, focus notes.
            if actionTaken != nil && notes.isEmpty {
                DispatchQueue.main.async { focusedField = .notes }
            }
        }
    }

    // MARK: - Subviews

    private var headerCard: some View {
        VStack(alignment: .leading, spacing: 6) {
            Text("Clinical Safety Alert")
                .font(.headline)
            Text("Review safety considerations before proceeding with assessment")
                .font(.subheadline)
                .foregroundStyle(.secondary)
        }
        .frame(maxWidth: .infinity, alignment: .leading)
        .padding()
        .background(.red.opacity(0.08), in: .rect(cornerRadius: 14))
        .overlay(alignment: .leading) {
            Image(systemName: "exclamationmark.triangle.fill")
                .foregroundStyle(.red)
                .padding(.leading, 10)
        }
        .accessibilityIdentifier("alertCard")
    }

    private var escalationCriteriaCard: some View {
        VStack(alignment: .leading, spacing: 12) {
            Text("IMMEDIATE ESCALATION CRITERIA").font(.headline)
            bullet("Immediate risk of harm to self or others")
            bullet("Active withdrawal requiring medical supervision")
            bullet("Severe mental health crisis")
            bullet("Inability to care for basic needs")
            Text("If any of these conditions are present, escalate immediately to emergency services")
                .font(.footnote).foregroundStyle(.secondary)
        }
        .frame(maxWidth: .infinity, alignment: .leading)
        .padding()
        .background(.ultraThinMaterial, in: .rect(cornerRadius: 14))
    }

    private func bullet(_ text: String) -> some View {
        HStack(alignment: .firstTextBaseline, spacing: 8) {
            Text("•"); Text(text)
        }
        .accessibilityElement(children: .combine)
    }

    private var actionPicker: some View {
        Menu {
            ForEach(ActionChoice.allCases) { c in
                Button(c.rawValue) { actionTaken = c }
            }
        } label: {
            HStack {
                Text("Action Taken")
                Spacer()
                Text(actionTaken?.rawValue ?? "Select action…")
                    .foregroundStyle(.secondary)
            }
            .padding()
            .background(.thinMaterial, in: .rect(cornerRadius: 12))
        }
        .accessibilityIdentifier("actionPicker")
    }

    @ViewBuilder private var notesEditor: some View {
        TextEditor(text: $notes)
            .frame(minHeight: 120)
            .padding(12)
            .background(.background, in: .rect(cornerRadius: 12))
            .overlay(
                RoundedRectangle(cornerRadius: 12).stroke(.quaternary)
            )
            .textInputAutocapitalization(.sentences)
            .submitLabel(.done)
            .accessibilityIdentifier("notesField")
    }

    // MARK: - Logic

    private var canContinue: Bool {
        (actionTaken != nil) &&
        !notes.trimmed.isEmpty &&
        acknowledged
    }

    private func validateAndContinue() {
        guard canContinue else {
            // Focus notes + inline error + gentle haptic
            showInlineError = true
            focusedField = .notes
            UINotificationFeedbackGenerator().notificationOccurred(.warning)
            return
        }
        onContinue(.init(action: actionTaken!, notes: notes.trimmed, acknowledged: acknowledged))
        isPresented = false
    }

    private var preferredDetents: Set<PresentationDetent> {
        // Settings-aware detents for iPad/large text
        let defaults: Set<PresentationDetent> = [.medium, .large]
        if dts >= .accessibility2 { return [.fraction(0.6), .large] }
        // Honor settings default
        if settings.defaultSheetDetentIndex == 0 { return defaults }
        return [.large, .medium]
    }

    private func withAppropriateAnimation(_ block: @escaping () -> Void) {
        if settings.reduceMotion {
            block()
        } else {
            withAnimation(.easeInOut(duration: 0.25), block)
        }
    }
}

// MARK: - String helper
private extension String {
    var trimmed: String { trimmingCharacters(in: .whitespacesAndNewlines) }
}
```

**What this gives you**

* Auto-focus Notes as soon as an action is chosen.
* No “sheet shoots off” when keyboard appears.
* Pullable sheet (`.medium`/`.large`) honoring your Settings.
* Continue disabled until valid; pressing it with empty notes focuses the field, shows inline error, and haptic.

---

# 2) Ultra-reliable focus (UIKit bridge, optional)

If you’ve ever seen SwiftUI lose focus on iPad, swap the `TextEditor` with this UIKit-backed view.

`AutofocusTextView.swift`:

```swift
import SwiftUI

struct AutofocusTextView: UIViewRepresentable {
    @Binding var text: String
    var shouldFocus: Bool

    func makeUIView(context: Context) -> UITextView {
        let tv = UITextView()
        tv.font = .preferredFont(forTextStyle: .body)
        tv.isScrollEnabled = true
        tv.backgroundColor = .clear
        tv.delegate = context.coordinator
        return tv
    }

    func updateUIView(_ uiView: UITextView, context: Context) {
        if uiView.text != text { uiView.text = text }
        if shouldFocus, uiView.window != nil, !uiView.isFirstResponder {
            uiView.becomeFirstResponder()
        }
    }

    func makeCoordinator() -> Coordinator { Coordinator(self) }

    final class Coordinator: NSObject, UITextViewDelegate {
        var parent: AutofocusTextView
        init(_ parent: AutofocusTextView) { self.parent = parent }
        func textViewDidChange(_ textView: UITextView) {
            parent.text = textView.text
        }
    }
}
```

Use it:

```swift
AutofocusTextView(text: $notes, shouldFocus: actionTaken != nil && notes.isEmpty)
    .frame(minHeight: 120)
    .padding(12)
    .background(.background, in: .rect(cornerRadius: 12))
    .overlay(RoundedRectangle(cornerRadius: 12).stroke(.quaternary))
    .id("notes")
```

---

# 3) Wire into your screen

Where you present the Safety Review:

```swift
@State private var showSafety = false
@StateObject private var settings = AppSettings()

.sheet(isPresented: $showSafety) {
    SafetyReviewSheet(isPresented: $showSafety) { result in
        // Persist into your Assessment / audit here
        // assessment.safetyAction = result.action.rawValue
        // assessment.safetyNotes = result.notes
        // assessment.safetyAck = result.acknowledged
    }
    .environmentObject(settings)
}
```

---

# 4) UI Tests (XCTest)

`SafetyReviewUITests.swift` — verifies gating + focus behavior.

```swift
import XCTest

final class SafetyReviewUITests: XCTestCase {
    func testSafetyReview_NotesRequiredAndFocuses() {
        let app = XCUIApplication()
        app.launchArguments += ["UITEST_SAFETY_REVIEW"]
        app.launch()

        // Open the sheet in your test build path
        app.buttons["openSafetyReview"].tap()

        let action = app.buttons["actionPicker"]
        XCTAssertTrue(action.waitForExistence(timeout: 2))

        // Pick an action
        action.tap()
        app.buttons["No immediate risk identified"].tap()

        // Notes field should exist and keyboard be visible soon after
        let notes = app.textViews["notesField"]
        XCTAssertTrue(notes.waitForExistence(timeout: 2))
        notes.typeText("Documented—no immediate risk.")

        // Continue becomes enabled after toggle
        let toggle = app.switches["ackToggle"]
        toggle.tap()

        let continueBtn = app.buttons["continueButton"]
        XCTAssertTrue(continueBtn.isEnabled)
        continueBtn.tap()
    }

    func testSafetyReview_DisablesContinueUntilValid() {
        let app = XCUIApplication()
        app.launch()

        app.buttons["openSafetyReview"].tap()
        app.buttons["actionPicker"].tap()
        app.buttons["Other"].tap()

        let continueBtn = app.buttons["continueButton"]
        XCTAssertFalse(continueBtn.isEnabled)

        // Try to continue: should show inline error and keep focus in notes
        continueBtn.tap()
        XCTAssertTrue(app.staticTexts["notesError"].exists)
    }
}
```

---

# 5) Accessibility & a11y notes (built in)

* Dynamic Type friendly (`dynamicTypeSize`, large detent if big text).
* Clear identifiers for UI tests: `actionPicker`, `notesField`, `continueButton`, etc.
* Uses `.scrollDismissesKeyboard(.interactively)` for predictable dismissal.

---

# 6) Settings tie-in (already honored)

* **Default sheet size:** `ui.defaultSheetDetentIndex` → chooses `.medium` vs `.large`.
* **Reduce motion:** avoids animated scrolling if `ui.reduceMotion` true.
* **Text size:** handled by Dynamic Type automatically.

If you’re using the enhanced Settings we discussed, you’re covered.

---

# 7) Small validation helper (optional)

If you want uniform validation across sheets, add:

```swift
enum FormValidator {
    static func require(_ condition: @autoclosure () -> Bool,
                        focus: () -> Void) -> Bool {
        if condition() { return true }
        UINotificationFeedbackGenerator().notificationOccurred(.warning)
        focus()
        return false
    }
}
```

Use inside `validateAndContinue()` to keep it tidy.

---

**That’s everything you need.**
Drop in the SwiftUI file, (optionally) the autofocus UIKit bridge, wire the sheet where you present it, and add the UI tests. You’ll get auto-cursor in Notes, stable sheet, pull-to-resize, and rock-solid validation.


>>

Awesome — here’s the exact, no-guesswork integration plan to get the new Safety Review flow (auto-focus Notes, stable/pullable sheet, validation, a11y, tests) running right now.

---

# Do this in order (copy/paste friendly)

## 1) Add the files (target membership = App)

Create these two files and add them to the **ASAMAssessment** target:

* `ios/ASAMAssessment/ASAMAssessment/Views/SafetyReviewSheet.swift`
  (use the full code I sent — includes detents, validation, a11y, haptics)

* *(Optional but recommended on iPad)*
  `ios/ASAMAssessment/ASAMAssessment/Views/UIKit/AutofocusTextView.swift`
  (swap into the sheet if you see any focus flakiness)

> Xcode → File ▸ New ▸ File… ▸ Swift file → paste → File Inspector → **Target Membership: ASAMAssessment ✅**

---

## 2) Wire it where you open Safety Review

Where you currently present the safety modal, replace with:

```swift
@State private var showSafety = false
@StateObject private var settings = AppSettings() // if not already injected

// Button to open:
Button {
    showSafety = true
} label: {
    Label("Review Safety", systemImage: "exclamationmark.triangle")
}
.accessibilityIdentifier("openSafetyReview") // used by UI tests

// Sheet:
.sheet(isPresented: $showSafety) {
    SafetyReviewSheet(isPresented: $showSafety) { result in
        // Persist into assessment/audit
        assessment.safetyAction = result.action.rawValue
        assessment.safetyNotes = result.notes
        assessment.safetyAcknowledged = result.acknowledged
        // If you gate progression, flip your “safetyComplete” flag here
    }
    .environmentObject(settings) // picks up default sheet size / reduceMotion
}
```

That’s it — the sheet now:

* **Auto-focuses** Notes as soon as an action is picked.
* **Doesn’t jump** when the keyboard shows (ignoresSafeArea + interactive dismissal).
* Is **pullable** (`.medium`/`.large`) with a grabber and honors your Settings default detent.

---

## 3) Turn on a couple of Settings (already supported)

Open your Settings (Enhanced):

* **Display & Layout → Sheet size**: choose your default (Medium or Large).
* **Display & Layout → Reduce motion**: off (for animated scroll to Notes), on if you need strict no-motion.

No new settings are required — the sheet reads these automatically.

---

## 4) UI tests (target membership = UI Tests)

Add `SafetyReviewUITests.swift` to your UI test target with the code I sent. If your “open Safety Review” button lives under a menu, add `.accessibilityIdentifier("openSafetyReview")` there or adjust the test to your nav.

Run:

```
xcodebuild \
  -scheme ASAMAssessmentUITests \
  -destination 'platform=iOS Simulator,name=iPad Pro (11-inch) (M4)' \
  test
```

---

## 5) Acceptance checklist (5 quick taps)

* Open Safety Review → **sheet has a grabber** and can resize between Medium/Large.
* Tap **Action Taken** → pick any value → **cursor lands in Notes** automatically.
* Type a few words → toggle **Acknowledged** → **Continue** enables.
* Tap **Continue** → sheet dismisses; assessment has `safetyAction`, `safetyNotes`, `safetyAcknowledged`.
* Try tapping **Continue** with empty Notes → haptic + inline error + focus remains in Notes.

---

## 6) Common gotchas (and the fix)

* **Sheet still jumps when keyboard shows**
  Make sure `SafetyReviewSheet` includes both:
  `.ignoresSafeArea(.keyboard, edges: .bottom)` and `.scrollDismissesKeyboard(.interactively)`.

* **Focus doesn’t jump to Notes**
  You replaced `TextEditor`? Keep the `.focused($focusedField, equals: .notes)` and the `DispatchQueue.main.asyncAfter` 0.15s in the `onChange(of: actionTaken)` block.
  If iPad is still flaky, swap in `AutofocusTextView` (UIKit bridge) as shown.

* **Continue never enables**
  The sheet requires **Action**, **non-empty Notes**, **Acknowledged**. If you want to relax this, update `canContinue`.

* **UITest can’t find controls**
  Check identifiers: `openSafetyReview`, `actionPicker`, `notesField`, `ackToggle`, `continueButton`.

---

## 7) Commit message template

```
feat(safety): autofocus Notes, stable/pullable sheet, validation, a11y, tests

- New SafetyReviewSheet (SwiftUI): auto-focus Notes after Action selection
- Prevents keyboard-induced jumps; interactive keyboard dismissal
- Presentation detents (.medium/.large) with Settings-aware default
- Inline validation + warning haptic; a11y identifiers for UI tests
- Optional AutofocusTextView (UIKit) for iPad focus reliability
- Added SafetyReview UI tests (focus + gating)
```

---

## 8) Optional polish (when you have a minute)

* Preselect **Action Taken** if your triage already inferred “No immediate risk” — the sheet will drop cursor straight into Notes on appear.
* Add a tiny “template” menu (e.g., “ED transfer”, “Contacted on-call”) to prefill Notes strings for speed.
* Log a small audit event when the sheet completes.

---

If you paste the two files and wire the `.sheet` exactly as above, you’ll get the behavior you asked for: **pick action → cursor in Notes**, **no sheet thrash**, **resizable by the user**, and **clean validation flow**.
